import { Injectable, Inject, PLATFORM_ID } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';

@Injectable({ providedIn: 'root' })
export class CSSOptimizationService {
  private readonly isBrowser: boolean;
  private usedClasses = new Set<string>();

  constructor(@Inject(PLATFORM_ID) private platformId: Object) {
    this.isBrowser = isPlatformBrowser(platformId);
  }

  // Track which CSS classes are actually used
  trackUsedClasses(): void {
    if (!this.isBrowser) return;

    // Monitor DOM changes to track class usage
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
          const element = mutation.target as HTMLElement;
          if (element.className) {
            element.className.split(' ').forEach(className => {
              if (className.trim()) {
                this.usedClasses.add(className.trim());
              }
            });
          }
        }
      });
    });

    // Start observing
    observer.observe(document.body, {
      attributes: true,
      attributeFilter: ['class'],
      subtree: true
    });

    // Track existing classes
    this.scanExistingClasses();
  }

  // Scan existing classes in the DOM
  private scanExistingClasses(): void {
    if (!this.isBrowser) return;

    const elements = document.querySelectorAll('*');
    elements.forEach(element => {
      if (element.className) {
        element.className.split(' ').forEach(className => {
          if (className.trim()) {
            this.usedClasses.add(className.trim());
          }
        });
      }
    });
  }

  // Generate critical CSS for above-the-fold content
  generateCriticalCSS(): string {
    const criticalClasses = [
      'min-h-screen', 'bg-white', 'dark:bg-slate-900', 'text-slate-900', 'dark:text-slate-100',
      'flex', 'items-center', 'justify-center', 'p-4', 'text-center',
      'w-full', 'h-full', 'relative', 'absolute', 'top-0', 'left-0',
      'z-50', 'backdrop-blur-lg', 'transition-all', 'duration-300',
      'text-5xl', 'md:text-6xl', 'lg:text-7xl', 'font-bold', 'leading-tight',
      'max-w-7xl', 'mx-auto', 'px-4', 'sm:px-6', 'lg:px-8', 'py-12'
    ];

    return criticalClasses
      .filter(className => this.usedClasses.has(className))
      .map(className => this.getCSSForClass(className))
      .join('\n');
  }

  // Get CSS for a specific class
  private getCSSForClass(className: string): string {
    // This would typically be generated by a build tool
    // For now, return a placeholder
    return `.${className} { /* CSS for ${className} */ }`;
  }

  // Remove unused CSS classes
  removeUnusedCSS(): void {
    if (!this.isBrowser) return;

    // This would typically be done at build time
    // For runtime, we can hide unused styles
    const styleSheets = document.styleSheets;
    for (let i = 0; i < styleSheets.length; i++) {
      try {
        const sheet = styleSheets[i];
        if (sheet.href && sheet.href.includes('tailwind')) {
          // Mark Tailwind CSS as potentially unused
          this.markStylesheetForOptimization(sheet);
        }
      } catch (e) {
        // Cross-origin stylesheets can't be accessed
        console.warn('Cannot access stylesheet:', e);
      }
    }
  }

  // Mark stylesheet for optimization
  private markStylesheetForOptimization(sheet: CSSStyleSheet): void {
    // Add a data attribute to mark for optimization
    const link = document.querySelector(`link[href*="tailwind"]`);
    if (link) {
      link.setAttribute('data-optimize', 'true');
    }
  }

  // Get used classes count
  getUsedClassesCount(): number {
    return this.usedClasses.size;
  }

  // Get used classes list
  getUsedClasses(): string[] {
    return Array.from(this.usedClasses);
  }

  // Generate CSS report
  generateCSSReport(): { used: number; total: number; unused: number } {
    const totalClasses = this.estimateTotalClasses();
    const used = this.usedClasses.size;
    const unused = totalClasses - used;

    return {
      used,
      total: totalClasses,
      unused
    };
  }

  // Estimate total CSS classes (rough estimate)
  private estimateTotalClasses(): number {
    // This is a rough estimate - in reality, you'd parse the actual CSS
    return 1000; // Estimated Tailwind CSS classes
  }

  // Optimize CSS loading
  optimizeCSSLoading(): void {
    if (!this.isBrowser) return;

    // Load non-critical CSS asynchronously
    const nonCriticalCSS = document.querySelectorAll('link[rel="stylesheet"]:not([data-critical])');
    nonCriticalCSS.forEach(link => {
      link.setAttribute('media', 'print');
      link.setAttribute('onload', "this.media='all'");
    });
  }
}
